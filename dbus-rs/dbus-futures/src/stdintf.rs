// This code was autogenerated with dbus-codegen-rust, see https://github.com/diwic/dbus-rs
// Then slightly hand edited.

pub mod org_freedesktop {

use dbus as dbus;
use dbus::arg;
use crate as dbusf;


pub trait DBus {
    fn hello(&self) -> dbusf::MethodReply<String>;
    fn request_name(&self, arg0: &str, arg1: u32) -> dbusf::MethodReply<u32>;
    fn release_name(&self, arg0: &str) -> dbusf::MethodReply<u32>;
    fn start_service_by_name(&self, arg0: &str, arg1: u32) -> dbusf::MethodReply<u32>;
    fn update_activation_environment(&self, arg0: ::std::collections::HashMap<&str, &str>) -> dbusf::MethodReply<()>;
    fn name_has_owner(&self, arg0: &str) -> dbusf::MethodReply<bool>;
    fn list_names(&self) -> dbusf::MethodReply<Vec<String>>;
    fn list_activatable_names(&self) -> dbusf::MethodReply<Vec<String>>;
    fn add_match(&self, arg0: &str) -> dbusf::MethodReply<()>;
    fn remove_match(&self, arg0: &str) -> dbusf::MethodReply<()>;
    fn get_name_owner(&self, arg0: &str) -> dbusf::MethodReply<String>;
    fn list_queued_owners(&self, arg0: &str) -> dbusf::MethodReply<Vec<String>>;
    fn get_connection_unix_user(&self, arg0: &str) -> dbusf::MethodReply<u32>;
    fn get_connection_unix_process_id(&self, arg0: &str) -> dbusf::MethodReply<u32>;
    fn get_adt_audit_session_data(&self, arg0: &str) -> dbusf::MethodReply<Vec<u8>>;
    fn get_connection_selinux_security_context(&self, arg0: &str) -> dbusf::MethodReply<Vec<u8>>;
    fn get_connection_app_armor_security_context(&self, arg0: &str) -> dbusf::MethodReply<String>;
    fn reload_config(&self) -> dbusf::MethodReply<()>;
    fn get_id(&self) -> dbusf::MethodReply<String>;
    fn get_connection_credentials(&self, arg0: &str) -> dbusf::MethodReply<::std::collections::HashMap<String, arg::Variant<Box<dyn arg::RefArg + 'static>>>>;
    fn get_features(&self) -> dbusf::MethodReply<Vec<String>>;
    fn get_interfaces(&self) -> dbusf::MethodReply<Vec<String>>;
}

impl<'a> DBus for dbusf::ConnPath<'a> {

    fn hello(&self) -> dbusf::MethodReply<String> {
        let m = self.method_call_with_args(&"org.freedesktop.DBus".into(), &"Hello".into(), |_| {
        });
        dbusf::MethodReply::from_msg(m, |m| {
            let mut i = m.iter_init();
            let arg0: String = i.read()?;
            Ok(arg0)
        })
    }

    fn request_name(&self, arg0: &str, arg1: u32) -> dbusf::MethodReply<u32> {
        let m = self.method_call_with_args(&"org.freedesktop.DBus".into(), &"RequestName".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
            i.append(arg1);
        });
        dbusf::MethodReply::from_msg(m, |m| {
            let mut i = m.iter_init();
            let arg0: u32 = i.read()?;
            Ok(arg0)
        })
    }

    fn release_name(&self, arg0: &str) -> dbusf::MethodReply<u32> {
        let m = self.method_call_with_args(&"org.freedesktop.DBus".into(), &"ReleaseName".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
        });
        dbusf::MethodReply::from_msg(m, |m| {
            let mut i = m.iter_init();
            let arg0: u32 = i.read()?;
            Ok(arg0)
        })
    }

    fn start_service_by_name(&self, arg0: &str, arg1: u32) -> dbusf::MethodReply<u32> {
        let m = self.method_call_with_args(&"org.freedesktop.DBus".into(), &"StartServiceByName".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
            i.append(arg1);
        });
        dbusf::MethodReply::from_msg(m, |m| {
            let mut i = m.iter_init();
            let arg0: u32 = i.read()?;
            Ok(arg0)
        })
    }

    fn update_activation_environment(&self, arg0: ::std::collections::HashMap<&str, &str>) -> dbusf::MethodReply<()> {
        let m = self.method_call_with_args(&"org.freedesktop.DBus".into(), &"UpdateActivationEnvironment".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
        });
        dbusf::MethodReply::from_msg(m, |_| {
            Ok(())
        })
    }

    fn name_has_owner(&self, arg0: &str) -> dbusf::MethodReply<bool> {
        let m = self.method_call_with_args(&"org.freedesktop.DBus".into(), &"NameHasOwner".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
        });
        dbusf::MethodReply::from_msg(m, |m| {
            let mut i = m.iter_init();
            let arg0: bool = i.read()?;
            Ok(arg0)
        })
    }

    fn list_names(&self) -> dbusf::MethodReply<Vec<String>> {
        let m = self.method_call_with_args(&"org.freedesktop.DBus".into(), &"ListNames".into(), |_| {
        });
        dbusf::MethodReply::from_msg(m, |m| {
            let mut i = m.iter_init();
            let arg0: Vec<String> = i.read()?;
            Ok(arg0)
        })
    }

    fn list_activatable_names(&self) -> dbusf::MethodReply<Vec<String>> {
        let m = self.method_call_with_args(&"org.freedesktop.DBus".into(), &"ListActivatableNames".into(), |_| {
        });
        dbusf::MethodReply::from_msg(m, |m| {
            let mut i = m.iter_init();
            let arg0: Vec<String> = i.read()?;
            Ok(arg0)
        })
    }

    fn add_match(&self, arg0: &str) -> dbusf::MethodReply<()> {
        let m = self.method_call_with_args(&"org.freedesktop.DBus".into(), &"AddMatch".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
        });
        dbusf::MethodReply::from_msg(m, |_| {
            Ok(())
        })
    }

    fn remove_match(&self, arg0: &str) -> dbusf::MethodReply<()> {
        let m = self.method_call_with_args(&"org.freedesktop.DBus".into(), &"RemoveMatch".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
        });
        dbusf::MethodReply::from_msg(m, |_| {
            Ok(())
        })
    }

    fn get_name_owner(&self, arg0: &str) -> dbusf::MethodReply<String> {
        let m = self.method_call_with_args(&"org.freedesktop.DBus".into(), &"GetNameOwner".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
        });
        dbusf::MethodReply::from_msg(m, |m| {
            let mut i = m.iter_init();
            let arg0: String = i.read()?;
            Ok(arg0)
        })
    }

    fn list_queued_owners(&self, arg0: &str) -> dbusf::MethodReply<Vec<String>> {
        let m = self.method_call_with_args(&"org.freedesktop.DBus".into(), &"ListQueuedOwners".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
        });
        dbusf::MethodReply::from_msg(m, |m| {
            let mut i = m.iter_init();
            let arg0: Vec<String> = i.read()?;
            Ok(arg0)
        })
    }

    fn get_connection_unix_user(&self, arg0: &str) -> dbusf::MethodReply<u32> {
        let m = self.method_call_with_args(&"org.freedesktop.DBus".into(), &"GetConnectionUnixUser".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
        });
        dbusf::MethodReply::from_msg(m, |m| {
            let mut i = m.iter_init();
            let arg0: u32 = i.read()?;
            Ok(arg0)
        })
    }

    fn get_connection_unix_process_id(&self, arg0: &str) -> dbusf::MethodReply<u32> {
        let m = self.method_call_with_args(&"org.freedesktop.DBus".into(), &"GetConnectionUnixProcessID".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
        });
        dbusf::MethodReply::from_msg(m, |m| {
            let mut i = m.iter_init();
            let arg0: u32 = i.read()?;
            Ok(arg0)
        })
    }

    fn get_adt_audit_session_data(&self, arg0: &str) -> dbusf::MethodReply<Vec<u8>> {
        let m = self.method_call_with_args(&"org.freedesktop.DBus".into(), &"GetAdtAuditSessionData".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
        });
        dbusf::MethodReply::from_msg(m, |m| {
            let mut i = m.iter_init();
            let arg0: Vec<u8> = i.read()?;
            Ok(arg0)
        })
    }

    fn get_connection_selinux_security_context(&self, arg0: &str) -> dbusf::MethodReply<Vec<u8>> {
        let m = self.method_call_with_args(&"org.freedesktop.DBus".into(), &"GetConnectionSELinuxSecurityContext".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
        });
        dbusf::MethodReply::from_msg(m, |m| {
            let mut i = m.iter_init();
            let arg0: Vec<u8> = i.read()?;
            Ok(arg0)
        })
    }

    fn get_connection_app_armor_security_context(&self, arg0: &str) -> dbusf::MethodReply<String> {
        let m = self.method_call_with_args(&"org.freedesktop.DBus".into(), &"GetConnectionAppArmorSecurityContext".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
        });
        dbusf::MethodReply::from_msg(m, |m| {
            let mut i = m.iter_init();
            let arg0: String = i.read()?;
            Ok(arg0)
        })
    }

    fn reload_config(&self) -> dbusf::MethodReply<()> {
        let m = self.method_call_with_args(&"org.freedesktop.DBus".into(), &"ReloadConfig".into(), |_| {
        });
        dbusf::MethodReply::from_msg(m, |_| {
            Ok(())
        })
    }

    fn get_id(&self) -> dbusf::MethodReply<String> {
        let m = self.method_call_with_args(&"org.freedesktop.DBus".into(), &"GetId".into(), |_| {
        });
        dbusf::MethodReply::from_msg(m, |m| {
            let mut i = m.iter_init();
            let arg0: String = i.read()?;
            Ok(arg0)
        })
    }

    fn get_connection_credentials(&self, arg0: &str) -> dbusf::MethodReply<::std::collections::HashMap<String, arg::Variant<Box<dyn arg::RefArg + 'static>>>> {
        let m = self.method_call_with_args(&"org.freedesktop.DBus".into(), &"GetConnectionCredentials".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
        });
        dbusf::MethodReply::from_msg(m, |m| {
            let mut i = m.iter_init();
            let arg0: ::std::collections::HashMap<String, arg::Variant<Box<dyn arg::RefArg + 'static>>> = i.read()?;
            Ok(arg0)
        })
    }

    fn get_features(&self) -> dbusf::MethodReply<Vec<String>> {
        <Self as dbusf::stdintf::org_freedesktop::DBusProperties>::get(&self, "org.freedesktop.DBus", "Features")
    }

    fn get_interfaces(&self) -> dbusf::MethodReply<Vec<String>> {
        <Self as dbusf::stdintf::org_freedesktop::DBusProperties>::get(&self, "org.freedesktop.DBus", "Interfaces")
    }
}

#[derive(Debug, Default)]
pub struct DBusNameOwnerChanged {
    pub name: String,
    pub old_owner: String,
    pub new_owner: String,
}

impl dbus::message::SignalArgs for DBusNameOwnerChanged {
    const NAME: &'static str = "NameOwnerChanged";
    const INTERFACE: &'static str = "org.freedesktop.DBus";
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.name, i);
        arg::RefArg::append(&self.old_owner, i);
        arg::RefArg::append(&self.new_owner, i);
    }
    fn get(&mut self, i: &mut arg::Iter) -> Result<(), arg::TypeMismatchError> {
        self.name = i.read()?;
        self.old_owner = i.read()?;
        self.new_owner = i.read()?;
        Ok(())
    }
}

#[derive(Debug, Default)]
pub struct DBusNameLost {
    pub arg0: String,
}

impl dbus::message::SignalArgs for DBusNameLost {
    const NAME: &'static str = "NameLost";
    const INTERFACE: &'static str = "org.freedesktop.DBus";
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.arg0, i);
    }
    fn get(&mut self, i: &mut arg::Iter) -> Result<(), arg::TypeMismatchError> {
        self.arg0 = i.read()?;
        Ok(())
    }
}

#[derive(Debug, Default)]
pub struct DBusNameAcquired {
    pub arg0: String,
}

impl dbus::message::SignalArgs for DBusNameAcquired {
    const NAME: &'static str = "NameAcquired";
    const INTERFACE: &'static str = "org.freedesktop.DBus";
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.arg0, i);
    }
    fn get(&mut self, i: &mut arg::Iter) -> Result<(), arg::TypeMismatchError> {
        self.arg0 = i.read()?;
        Ok(())
    }
}

pub trait DBusProperties {
    fn get<R0: 'static + for<'b> arg::Get<'b>>(&self, arg0: &str, arg1: &str) -> dbusf::MethodReply<R0>;
    fn get_all(&self, arg0: &str) -> dbusf::MethodReply<::std::collections::HashMap<String, arg::Variant<Box<dyn arg::RefArg + 'static>>>>;
    fn set<I2: arg::Arg + arg::Append>(&self, arg0: &str, arg1: &str, arg2: I2) -> dbusf::MethodReply<()>;
}

impl<'a> DBusProperties for dbusf::ConnPath<'a> {

    fn get<R0: 'static + for<'b> arg::Get<'b>>(&self, arg0: &str, arg1: &str) -> dbusf::MethodReply<R0> {
        let m = self.method_call_with_args(&"org.freedesktop.DBus.Properties".into(), &"Get".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
            i.append(arg1);
        });
        dbusf::MethodReply::from_msg(m, |m| {
            let mut i = m.iter_init();
            let arg0: arg::Variant<R0> = i.read()?;
            Ok(arg0.0)
        })
    }

    fn get_all(&self, arg0: &str) -> dbusf::MethodReply<::std::collections::HashMap<String, arg::Variant<Box<dyn arg::RefArg + 'static>>>> {
        let m = self.method_call_with_args(&"org.freedesktop.DBus.Properties".into(), &"GetAll".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
        });
        dbusf::MethodReply::from_msg(m, |m| {
            let mut i = m.iter_init();
            let arg0: ::std::collections::HashMap<String, arg::Variant<Box<dyn arg::RefArg + 'static>>> = i.read()?;
            Ok(arg0)
        })
    }

    fn set<I2: arg::Arg + arg::Append>(&self, arg0: &str, arg1: &str, arg2: I2) -> dbusf::MethodReply<()> {
        let m = self.method_call_with_args(&"org.freedesktop.DBus.Properties".into(), &"Set".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
            i.append(arg1);
            i.append(arg::Variant(arg2));
        });
        dbusf::MethodReply::from_msg(m, |_| {
            Ok(())
        })
    }
}

#[derive(Debug, Default)]
pub struct DBusPropertiesPropertiesChanged {
    pub interface_name: String,
    pub changed_properties: ::std::collections::HashMap<String, arg::Variant<Box<dyn arg::RefArg + 'static>>>,
    pub invalidated_properties: Vec<String>,
}

impl dbus::message::SignalArgs for DBusPropertiesPropertiesChanged {
    const NAME: &'static str = "PropertiesChanged";
    const INTERFACE: &'static str = "org.freedesktop.DBus.Properties";
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.interface_name, i);
        arg::RefArg::append(&self.changed_properties, i);
        arg::RefArg::append(&self.invalidated_properties, i);
    }
    fn get(&mut self, i: &mut arg::Iter) -> Result<(), arg::TypeMismatchError> {
        self.interface_name = i.read()?;
        self.changed_properties = i.read()?;
        self.invalidated_properties = i.read()?;
        Ok(())
    }
}

pub trait DBusIntrospectable {
    fn introspect(&self) -> dbusf::MethodReply<String>;
}

impl<'a> DBusIntrospectable for dbusf::ConnPath<'a> {

    fn introspect(&self) -> dbusf::MethodReply<String> {
        let m = self.method_call_with_args(&"org.freedesktop.DBus.Introspectable".into(), &"Introspect".into(), |_| {
        });
        dbusf::MethodReply::from_msg(m, |m| {
            let mut i = m.iter_init();
            let arg0: String = i.read()?;
            Ok(arg0)
        })
    }
}

pub trait DBusMonitoring {
    fn become_monitor(&self, arg0: Vec<&str>, arg1: u32) -> dbusf::MethodReply<()>;
}

impl<'a> DBusMonitoring for dbusf::ConnPath<'a> {

    fn become_monitor(&self, arg0: Vec<&str>, arg1: u32) -> dbusf::MethodReply<()> {
        let m = self.method_call_with_args(&"org.freedesktop.DBus.Monitoring".into(), &"BecomeMonitor".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
            i.append(arg1);
        });
        dbusf::MethodReply::from_msg(m, |_| {
            Ok(())
        })
    }
}

pub trait DBusDebugStats {
    fn get_stats(&self) -> dbusf::MethodReply<::std::collections::HashMap<String, arg::Variant<Box<dyn arg::RefArg + 'static>>>>;
    fn get_connection_stats(&self, arg0: &str) -> dbusf::MethodReply<::std::collections::HashMap<String, arg::Variant<Box<dyn arg::RefArg + 'static>>>>;
    fn get_all_match_rules(&self) -> dbusf::MethodReply<::std::collections::HashMap<String, Vec<String>>>;
}

impl<'a> DBusDebugStats for dbusf::ConnPath<'a> {

    fn get_stats(&self) -> dbusf::MethodReply<::std::collections::HashMap<String, arg::Variant<Box<dyn arg::RefArg + 'static>>>> {
        let m = self.method_call_with_args(&"org.freedesktop.DBus.Debug.Stats".into(), &"GetStats".into(), |_| {
        });
        dbusf::MethodReply::from_msg(m, |m| {
            let mut i = m.iter_init();
            let arg0: ::std::collections::HashMap<String, arg::Variant<Box<dyn arg::RefArg + 'static>>> = i.read()?;
            Ok(arg0)
        })
    }

    fn get_connection_stats(&self, arg0: &str) -> dbusf::MethodReply<::std::collections::HashMap<String, arg::Variant<Box<dyn arg::RefArg + 'static>>>> {
        let m = self.method_call_with_args(&"org.freedesktop.DBus.Debug.Stats".into(), &"GetConnectionStats".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
        });
        dbusf::MethodReply::from_msg(m, |m| {
            let mut i = m.iter_init();
            let arg0: ::std::collections::HashMap<String, arg::Variant<Box<dyn arg::RefArg + 'static>>> = i.read()?;
            Ok(arg0)
        })
    }

    fn get_all_match_rules(&self) -> dbusf::MethodReply<::std::collections::HashMap<String, Vec<String>>> {
        let m = self.method_call_with_args(&"org.freedesktop.DBus.Debug.Stats".into(), &"GetAllMatchRules".into(), |_| {
        });
        dbusf::MethodReply::from_msg(m, |m| {
            let mut i = m.iter_init();
            let arg0: ::std::collections::HashMap<String, Vec<String>> = i.read()?;
            Ok(arg0)
        })
    }
}

pub trait DBusPeer {
    fn get_machine_id(&self) -> dbusf::MethodReply<String>;
    fn ping(&self) -> dbusf::MethodReply<()>;
}

impl<'a> DBusPeer for dbusf::ConnPath<'a> {

    fn get_machine_id(&self) -> dbusf::MethodReply<String> {
        let m = self.method_call_with_args(&"org.freedesktop.DBus.Peer".into(), &"GetMachineId".into(), |_| {
        });
        dbusf::MethodReply::from_msg(m, |m| {
            let mut i = m.iter_init();
            let arg0: String = i.read()?;
            Ok(arg0)
        })
    }

    fn ping(&self) -> dbusf::MethodReply<()> {
        let m = self.method_call_with_args(&"org.freedesktop.DBus.Peer".into(), &"Ping".into(), |_| {
        });
        dbusf::MethodReply::from_msg(m, |_| {
            Ok(())
        })
    }
}

}
